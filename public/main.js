/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/grid.js":
/*!*********************!*\
  !*** ./src/grid.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ Grid\n/* harmony export */ });\nclass Grid {\n\n    constructor() {\n        this.board = document.getElementById('board');\n        \n        this.ArrayOfVisibleRows = [];\n        this.divArray = [];\n        \n        this.rowcount = 1; //initial row value\n        this.columncount = 1; //initial column value\n        this.maxRows = 19; //safe to adjust\n        this.maxColumns = 16;\n        this.tile = 30; //determines grid unit size\n        this.rightedge = 13;\n        this.leftedge = 4;\n        this.floor = 2;\n        this.bottom = 0;\n        this.left = 0;\n        \n        // let points = 0;\n        // let speedTracker = 0;\n        // let speed = 500;\n        // let timer;\n        // let deletedrow = 0;\n        // let shapeOrientation;\n    }\n\n    createRow() {\n        let i;\n        for (i=0; i<this.maxColumns; i++) {\n            //lets us keep increasing the array index for each iteration of createRow()\n            let indexAdjuster = (this.rowcount - 1) * this.maxColumns; //\n            let index = i + indexAdjuster;\n    \n            this.divArray.push(document.createElement('DIV'))\n            this.divArray[index].setAttribute('class','blank')\n            this.board.appendChild(this.divArray[index]); //adds div to board div\n            this.divArray[index].style.bottom = `${this.bottom}px`; //positioning\n            this.divArray[index].style.left = `${this.left}px`; //positioning\n            this.left += this.tile;\n            this.divArray[index].column = this.columncount; \n            this.columncount +=1;\n            this.divArray[index].row = this.rowcount; \n            this.divArray[index].idabove = `r${this.divArray[index].row + 1}c${this.divArray[index].column}`\n            this.divArray[index].idbelow = `r${this.divArray[index].row - 1}c${this.divArray[index].column}`\n            this.divArray[index].idright = `r${this.divArray[index].row}c${this.divArray[index].column + 1}`\n            this.divArray[index].idleft = `r${this.divArray[index].row}c${this.divArray[index].column - 1}`\n            this.divArray[index].setAttribute('id', `r${this.divArray[index].row}c${this.divArray[index].column}`) //sets id with row1column2 format for simpler manipulation\n        }\n    }\n    \n    \n    //NOTE: we need to add 2 or 3 hidden rows at the top to allow the new shapes to generate 'off-screen'\n    createGrid() {\n        let k; //using k, since we used i on inside loop (createRow)\n        for (k=0;k<this.maxRows;k++) {\n            let array = []\n            this.createRow(); //fills in the entire row, adjusting all necessary variables within this inner function.\n    \n            this.divArray.forEach( e => { //adds array to the Row Array.\n                if ( e.row === this.rowcount && e.column >= this.leftedge && e.column <= this.rightedge ) {\n                    array.push(e);\n                }\n            });\n            this.ArrayOfVisibleRows.push(array); //populates ArrayOfVisibleRows\n    \n            this.left = 0; //Now that the row is created, we reset and adjust variables for next row:\n          this.  bottom += this.tile;\n            this.rowcount += 1;\n            this.columncount = 1;\n        }\n    }\n    \n    hideBottomRow() {\n        this.bottomRow = [];\n        let i;\n        for (i=0;i<this.divArray.length;i++) {\n            if (this.divArray[i].row < this.floor) {\n              this.  bottomRow.push(this.divArray[i]);\n            }\n        }\n      this.bottomRow.forEach(e => {\n            e.style.visibility = 'hidden';\n        })\n    }\n    \n    \n    hideTopTwoRows() {\n        const topRows = [];\n    \n        let i;\n        for (i=0;i<this.divArray.length;i++) {\n            if (this.divArray[i].row > 17) {\n                topRows.push(this.divArray[i]);\n            }\n        }\n        topRows.forEach(e => e.style.visibility = 'hidden');\n    }\n    \n    hideOuterColumns() {\n        const oustideColumns = [];\n        let i;\n        for (i=0;i<this.divArray.length;i++) {\n            if (this.divArray[i].column < this.leftedge || this.divArray[i].column > this.rightedge) {\n                oustideColumns.push(this.divArray[i]);\n            }\n        }\n        oustideColumns.forEach(e => e.style.visibility = 'hidden');\n       \n    }\n    \n    //ASSIGNS EACH ELEMENT TO A VARIABLE THAT IS THE SAME AS THE ELEMENT ID\n   assignNamesToAllDivs() {\n        this.divArray.forEach( e => {\n            this[e.id] = e;\n        })\n    }\n\n}\n\n\n// //INITIALIZE BOARD\n// createGrid();\n// assignNamesToAllDivs();\n// hideBottomRow();\n// hideTopTwoRows();\n// hideOuterColumns();\n\n//# sourceURL=webpack://tetris/./src/grid.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_grid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../src/grid.js */ \"./src/grid.js\");\n/* harmony import */ var _src_tetrimino_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../src/tetrimino.js */ \"./src/tetrimino.js\");\n//Useful methods\n//document.createElement\n//document.getElementById('parent').appendChild(childelement)\n\n\n//Grid Style: \n// - Reassigns divs in the grid to create the illusion of one falling tetrimino.\n// - create a function on an interval that fills a certain starting set of blocks, \n// - reassigning their properties (color. position, status). and moves these every interval.\n\n\n\n\nconst grid = new _src_grid_js__WEBPACK_IMPORTED_MODULE_0__.default;\n\n\n//Grid Vars\n// const board = document.getElementById('board');\n// let ArrayOfVisibleRows = [];\n// let grid.divArray = [];\n// let rowcount = 1; //initial row value\n// let columncount = 1; //initial column value\n// let maxRows = 19; //safe to adjust\n// let maxColumns = 16;\n// const tile = 30; //determines grid unit size\n// const rightedge = 13;\n// const leftedge = 4;\n// const floor = 2;\n// let bottom = 0;\n// let left = 0;\n\n//GLOBAL VARS\nconst score = document.getElementById('score');\nconst newGameButton = document.getElementById('new-game');\nconst prompt = document.getElementById('restart');\nconst bonusScreen = document.getElementById('bonus');\n\nlet points = 0;\nlet speedTracker = 0;\nlet speed = 500;\nlet timer;\n\n\n\n\n//EVENT LISTENERS\ndocument.addEventListener('keydown', leftEventHandler);\ndocument.addEventListener('keydown', rightEventHandler);\ndocument.addEventListener('keydown', downEventHandler);\ndocument.addEventListener('keydown', rotateEventHandler);\ndocument.addEventListener('keyup', slamEventHandler);\nnewGameButton.addEventListener('click', restart);\n\n\n\n//INITIALIZE BOARD\ngrid.createGrid();\ngrid.assignNamesToAllDivs();\ngrid.hideBottomRow();\ngrid.hideTopTwoRows();\ngrid.hideOuterColumns();\n\nupdateScore();\nupdateSpeed();\n//row 16 is the visible top, row 2 is the visible bottom.\nconsole.log(grid.ArrayOfVisibleRows);\nconsole.log(grid);\nconsole.log('banana', grid.banana);\nconsole.log('WEBPACK W TEST')\n\n\n//INTIALIZE SHAPES\n// const lTetrimino = [r16c7, r16c8, r16c9, r17c9]; \n// const jTetrimino = [r16c7, r16c8, r16c9, r17c7];\n// const sqTetrimino = [r16c8, r16c9, r17c8, r17c9]; //square shape\n// const iTetrimino = [r16c7, r16c8, r16c9, r16c10];\n// const tTetrimino = [r16c7, r16c8, r16c9, r17c8];\n// const z1Tetrimino = [r16c8, r16c9, r17c7, r17c8];\n// const sTetrimino = [r16c7, r16c8, r17c8, r17c9];\n// const arrayOfTetriminos = [lTetrimino, jTetrimino, sqTetrimino, iTetrimino, tTetrimino, z1Tetrimino, sTetrimino];\n// const arrayOfShapeOrientations = ['l1', 'j1', 'sq1', 'i1', 't1', 'z1', 's1'];\n// const z2Tetrimino = [r16c8, r17c8, r17c9, r16c9]; //testing only\n\n\n//CREATE TETRIMINO ClASS (VERY LARGE CLASS/OBJECT. CAN WE DO SOMETHING ABOUT THIS?)\n\n\n\n\n//START\n\nlet Mino = new _src_tetrimino_js__WEBPACK_IMPORTED_MODULE_1__.default(grid);\nMino.generate();\nrun();\n\n\n\n\n\n\n//GLOBAL FUNCTIONS\n\nfunction run() { \n    timer = setTimeout(fall, speed);\n}\n\nfunction fall() {\n    if (!Mino.isDownBlocked) {\n        Mino.lower();\n        run()\n    } else {\n        Mino.makeStatic(); //freeze block in place\n        checkRowState(); //delete filled rows, downshifts static pieces\n        if (isGameOver()){\n            promptRestart();\n        } else {\n            Mino.generate();\n            run();\n        }\n    }   \n}\n\nfunction promptRestart() {\n    prompt.style.display = 'flex';\n    let h3 = document.getElementById('endscore');\n    h3.innerHTML = `Your score is ${points}.`\n}\n\nfunction restart() {\n    grid.divArray.forEach( e => {\n        e.className = 'blank';\n    })\n    prompt.style.display = 'none';\n    points = 0;\n    speedTracker = 0;\n    speed = 500;\n    updateScore();\n    updateSpeed();\n    Mino.generate();\n    run();\n}\n\n\nfunction updateSpeed() {\n    if (speed > 160 && speedTracker%5 === 0) {\n        speed = 500 - ((speedTracker/5) * 20);\n    } else {\n        return;\n    }\n}\n\nfunction updateScore() {\n    score.innerHTML = `Score: ${points}`;\n    console.log(speedTracker, speed);\n}\n\n\n\n// function getStatics() {\n//     let statics = document.getElementsByClassName('static');\n//     let array = [];\n//     let i;\n//     for (i=0;i<statics.length;i++) {\n//         array.push(statics[i])\n//     }\n//     return array;\n// }\n\n\n// function staticReassign(aboveSquare) { //takes an element. as long as elements go from bottom up should nto overwrite itself.\n//     aboveSquare.className = 'blank';\n//     grid[aboveSquare.idbelow].className = 'static';\n// }\n\n\n// //Finds all statics above the deleted row, then move them down\n// function downShiftStatics() {\n//     console.log('deleted row: ', deletedrow);\n//     getStatics().forEach( e => {\n//         if (e.row > deletedrow) {\n//             staticReassign(e);\n//         }\n//     })\n// }\n\n\n// function clearRow(index) {\n//     removeHighlight();\n//     deletedrow = grid.ArrayOfVisibleRows[index][0].row;\n//     grid.ArrayOfVisibleRows[index].forEach( e => {\n//         e.className = 'blank';\n//     })\n// }\n\n\n\nfunction checkRowState() {\n    let rowsCleared = 0;\n\n    function isFilled(elem, index, arr) { //callback function for .every\n        return elem.className === 'static';\n    }\n\n    let i;\n    for (i=0;i<grid.maxRows;i++) {\n        if (grid.ArrayOfVisibleRows[i].every(isFilled)) {\n            Mino.clearRow(i);\n            Mino.downShiftStatics();\n            speedTracker += 1;\n            rowsCleared += 1; //for calculating score bonuses\n            i -= 1; //accounts for multiple rows clearing 'at once.'\n           \n        }\n    }\n\n    if (rowsCleared === 1) {\n        points += 1;\n        updateScore();\n        updateSpeed();\n        bonusScreen.innerHTML = '<div>+1</div>';\n        bonusScreen.style.display = 'flex';\n        setTimeout( ()=> {\n            bonusScreen.style.display = 'none';\n        }, 1300)\n    }\n    if (rowsCleared === 2) {\n        points += 4 ;//includes bonus\n        updateScore();\n        updateSpeed();\n        bonusScreen.innerHTML = '<div>+4!</div>';\n        bonusScreen.style.display = 'flex';\n        setTimeout( ()=> {\n            bonusScreen.style.display = 'none';\n        }, 1300)\n    }\n    if (rowsCleared === 3) {\n        points += 8 ;//includes bonus\n        updateScore();\n        bonusScreen.innerHTML = '<div>+8!</div>';\n        bonusScreen.style.display = 'flex';\n        setTimeout( ()=> {\n            bonusScreen.style.display = 'none';\n        }, 1300)\n    }\n    if (rowsCleared === 4) {\n        points += 14 ;//includes bonus\n        updateScore();\n        updateSpeed();\n        bonusScreen.innerHTML = '<div>TETRIS!</div><div>+14!</div>';\n        bonusScreen.style.display = 'flex';\n        setTimeout( ()=> {\n            bonusScreen.style.display = 'none';\n        }, 1300)\n    }\n}\n\n// function removeHighlight() {\n//     let j;\n//     let array = [];\n//     grid.divArray.forEach( e => {\n//         if (e.style.backgroundColor = 'lime') {\n//             array.push(e)\n//         }\n//     })\n//     for (j=0;j<array.length;j++) {\n//         array[j].style.backgroundColor = '';\n//     }\n// }\n\nfunction isGameOver() {\n    let i;\n    for (i=0;i<grid.ArrayOfVisibleRows[14].length;i++) {\n        if (grid.ArrayOfVisibleRows[16][i].className === 'static') {\n            console.log('GAME OVER');\n            return true;\n            break;\n        }\n    }\n    return false;\n}\n\n// function createRow() {\n//     let i;\n//     for (i=0; i<maxColumns; i++) {\n//         //lets us keep increasing the array index for each iteration of createRow()\n//         let indexAdjuster = (rowcount - 1) * maxColumns; //\n//         let index = i + indexAdjuster;\n\n//         divArray.push(document.createElement('DIV'))\n//         divArray[index].setAttribute('class','blank')\n//         board.appendChild(divArray[index]); //adds div to board div\n//         divArray[index].style.bottom = `${bottom}px`; //positioning\n//         divArray[index].style.left = `${left}px`; //positioning\n//         left += tile;\n//         divArray[index].column = columncount; \n//         columncount +=1;\n//         divArray[index].row = rowcount; \n//         divArray[index].idabove = `r${divArray[index].row + 1}c${divArray[index].column}`\n//         divArray[index].idbelow = `r${divArray[index].row - 1}c${divArray[index].column}`\n//         divArray[index].idright = `r${divArray[index].row}c${divArray[index].column + 1}`\n//         divArray[index].idleft = `r${divArray[index].row}c${divArray[index].column - 1}`\n//         divArray[index].setAttribute('id', `r${divArray[index].row}c${divArray[index].column}`) //sets id with row1column2 format for simpler manipulation\n//     }\n// }\n\n\n// //NOTE: we need to add 2 or 3 hidden rows at the top to allow the new shapes to generate 'off-screen'\n// function createGrid() {\n//     let k; //using k, since we used i on inside loop (createRow)\n//     for (k=0;k<maxRows;k++) {\n//         let array = []\n//         createRow(); //fills in the entire row, adjusting all necessary variables within this inner function.\n\n//         divArray.forEach( e => { //adds array to the Row Array.\n//             if ( e.row === rowcount && e.column >= grid.leftedge && e.column <= grid.rightedge ) {\n//                 array.push(e);\n//             }\n//         });\n//         ArrayOfVisibleRows.push(array); //populates ArrayOfVisibleRows\n\n//         left = 0; //Now that the row is created, we reset and adjust variables for next row:\n//         bottom += tile;\n//         rowcount += 1;\n//         columncount = 1;\n//     }\n// }\n\n// function hideBottomRow() {\n//     const bottomRow = [];\n//     let i;\n//     for (i=0;i<divArray.length;i++) {\n//         if (divArray[i].row < grid.floor) {\n//             bottomRow.push(divArray[i]);\n//         }\n//     }\n//     bottomRow.forEach(e => {\n//         e.style.visibility = 'hidden';\n//     })\n// }\n\n\n// function hideTopTwoRows() {\n//     const topRows = [];\n\n//     let i;\n//     for (i=0;i<divArray.length;i++) {\n//         if (divArray[i].row > 17) {\n//             topRows.push(divArray[i]);\n//         }\n//     }\n//     topRows.forEach(e => e.style.visibility = 'hidden');\n// }\n\n// function hideOuterColumns() {\n//     const oustideColumns = [];\n//     let i;\n//     for (i=0;i<divArray.length;i++) {\n//         if (divArray[i].column < grid.leftedge || divArray[i].column > grid.rightedge) {\n//             oustideColumns.push(divArray[i]);\n//         }\n//     }\n//     oustideColumns.forEach(e => e.style.visibility = 'hidden');\n   \n// }\n\n// //ASSIGNS EACH ELEMENT TO A VARIABLE THAT IS THE SAME AS THE ELEMENT ID\n// function assignNamesToAllDivs() {\n//     divArray.forEach( e => {\n//         window[`e.id`] = e;\n//     })\n// }\n\n////\n\n\n\n\n\n\n\n//EVENT HANDLERS\nfunction leftEventHandler(e) {\n    if (e.keyCode == 37 && !Mino.isLeftBlocked) {\n        Mino.moveLeft();\n    }\n}\n\nfunction rightEventHandler(e) {\n    if (e.keyCode == 39 && !Mino.isRightBlocked) {\n        Mino.moveRight();\n    }\n}\n\nfunction downEventHandler(e) {\n    if (e.keyCode == 40 && !Mino.isDownBlocked) {\n        Mino.lower();\n    }\n}\n\nfunction rotateEventHandler(e) {\n    if (e.keyCode == 38) {\n        Mino.rotate();\n    }\n}\n\nfunction slamEventHandler(e) {\n    if (e.keyCode == 32) {\n        Mino.slam();\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//TESTING SECTIONS\n\n\n// function testStatic() {\n//     grid.divArray.forEach(e => {\n//         if (e.column >= grid.leftedge && e.row >= grid.floor && e.row < 4 && e.column < 12) {\n//             e.className = 'static';\n//         }\n//     })\n// }\n\n\n//OPERATE ONCE\n// Mino.generate();\n// Mino.lower();\n// console.log(Mino.actives);\n// Mino.actives.forEach( e => console.log(e.tracker));\n// console.log(Mino.actives.sort((a,b) => a.tracker - b.tracker))\n\n\n\n// OPERATE FALL\n// testStatic();\n// Mino.generate();\n// setInterval(fall, 350);\n\n\n//increasing speed\n\n\n\n//NOTES\n//FUNCTION FOR GRABBING ARRAY OF ACTIVE SQUARES\n// the reason i am making an identical array is so that there is an array with value types, not reference\n// creates an identical array, but of value types (not reference)\n// technically array is not an array, its only array-like, so i cannot use .map on it.\n\n\n// function getArrayOfActiveSquares() {\n//     let array = [];\n//     const arrayLikeObject = document.getElementsByClassName('active');\n//     let i;\n//     for (i=0;i<arrayLikeObject.length;i++) {\n//         array.push(arrayLikeObject[i]);\n//     }\n//     return array;\n// }\n\n\n// function generateZ1Tetrimino() {\n//     z1Tetrimino.forEach( e => {e.className = 'active'});\n//     // assignTracker(z1Tetrimino);\n//     shapeOrientation = 'z1';\n// }\n\n// function generateZ2Tetrimino() {\n//     z2Tetrimino.forEach( e => {e.className = 'active'});\n//     // assignTracker(z2Tetrimino);\n//     shapeOrientation = 'z2';\n// }\n\n// function generateTTetrimino() {\n//     tTetrimino.forEach( e => {e.className = 'active'});\n//     shapeOrientation = 't1';\n// }\n\n// function generateITetrimino() {\n//     iTetrimino.forEach( e => {e.className = 'active'});\n//     shapeOrientation = 'i1';\n// }\n\n// function generateSTetrimino() {\n//     sTetrimino.forEach( e => {e.className = 'active'});\n//     shapeOrientation = 's1';\n// }\n\n// function generateLTetrimino() {\n//     lTetrimino.forEach( e => {e.className = 'active'});\n//     shapeOrientation = 'l1';\n// }\n\n// function generateJTetrimino() {\n//     jTetrimino.forEach( e => {e.className = 'active'});\n//     shapeOrientation = 'j1';\n// }\n\n\n// console.log(getStatics());\n\n// function testLeftTest(nextArray) {\n//     let testArray = []\n//     nextArray.forEach(e => {\n//         testArray.push(window[e.idleft]);\n//     })\n//     console.log(testArray);\n// }\n\n// generateTTetrimino();\n// generateLTetrimino();\n// Mino.rotate();\n// testStatic();\n// testLeftTest(lTetrimino);\n// generateITetrimino();\n// generateJTetrimino();\n\n//why does ROTATE BACK FAIL?\n\n//STATIC Z1\n// generateZ1Tetrimino();\n// Mino.lower();\n// Mino.moveRight();\n// Mino.moveLeft();\n// Mino.moveLeft();\n// Mino.moveRight();\n// Mino.moveRight();\n// Mino.moveRight();\n// Mino.lower();\n\n// Mino.rotate();\n// Mino.rotate(); \n// console.log('actives alphabetically', Mino.actives);\n// console.log('current orientation', shapeOrientation)\n// Mino.actives.forEach( e => console.log(e.tracker));\n// console.log('sorted by ascending trackers', Mino.actives.sort((a,b) => a.tracker - b.tracker));\n\n//STATIC Z2\n// generateZ2Tetrimino();\n// Mino.rotate();\n// Mino.rotate();\n// Mino.rotate();\n// Mino.rotate();\n// console.log('actives alphabetically', Mino.actives);\n// console.log('current orientation', shapeOrientation)\n// Mino.actives.forEach( e => console.log(e.tracker));\n// console.log('sorted by ascending trackers', Mino.actives.sort((a,b) => a.tracker - b.tracker));\n\n// FALLING Z2\n// generateZ2Tetrimino();\n// setInterval(fallingZ, 1000);\n\n\n//STATIC T Tetrimino - WORKS\n// generateTTetrimino();\n// console.log('orientation', shapeOrientation)\n\n\n\n// Mino.rotate(); //t2\n// console.log('orientation', shapeOrientation)\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate(); //t3\n// console.log('orientation', shapeOrientation)\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate(); //t4\n// console.log('orientation', shapeOrientation)\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate(); //t1\n// console.log('orientation', shapeOrientation)\n// console.log('actives alphabetically', Mino.actives);\n\n//FALLING T1 - WORKS\n// generateTTetrimino();\n// setInterval(fallingT, 1000);\n\n\n// STATIC I Tetrimino - WORKS\n// generateITetrimino();\n// console.log('orientation', shapeOrientation)\n// Mino.rotate();\n// console.log('orientation', shapeOrientation)\n// Mino.rotate();\n// console.log('orientation', shapeOrientation)\n\n// FALLING I1 - WORKS\n// generateITetrimino();\n// setInterval(fallingI, 1000);\n\n\n\n// STATIC S Tetrimino - Works\n// generateSTetrimino();\n// console.log('orientation', shapeOrientation)\n// Mino.rotate();\n// console.log('orientation', shapeOrientation);\n// Mino.rotate();\n// console.log('orientation', shapeOrientation);\n// Mino.rotate();\n// console.log('orientation', shapeOrientation);\n// Mino.rotate();\n// console.log('orientation', shapeOrientation);\n\n// FALLING S1 - Works\n// generateSTetrimino();\n// setInterval(fallingS, 1000);\n\n// STATIC L Tetrimino - WORKS\n// generateLTetrimino(); \n// console.log('orientation', shapeOrientation);\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate(); //l2\n// console.log('orientation', shapeOrientation);\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate(); //l3\n// console.log('orientation', shapeOrientation);\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate(); //l4\n// console.log('orientation', shapeOrientation);\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate();  //l1\n// console.log('orientation', shapeOrientation);\n// console.log('actives alphabetically', Mino.actives);\n\n\n// FALLING L1 - Works\n// generateLTetrimino();\n// setInterval(fallingL, 1000);\n\n//STATIC J - WORKS\n// generateJTetrimino();\n// console.log('orientation', shapeOrientation);\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate();\n// console.log('orientation', shapeOrientation);\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate();\n// console.log('orientation', shapeOrientation);\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate();\n// console.log('orientation', shapeOrientation);\n// console.log('actives alphabetically', Mino.actives);\n// Mino.rotate();\n// console.log('orientation', shapeOrientation);\n// console.log('actives alphabetically', Mino.actives);\n\n// FALLING J1 - WORKS\n// generateJTetrimino();\n// setInterval(fallingJ, 1000);\n\n\n\n\n\n\n//TEST SHAPES\n\n// function fallingZ() {\n//     if (!Mino.isDownBlocked) {\n//         Mino.rotate();\n//         Mino.lower();\n//     } else {\n//     Mino.makeStatic(); //freeze block in place\n//     generateZ2Tetrimino();\n//     }\n// }\n\n// function fallingT() {\n//     if (!Mino.isDownBlocked) {\n//         Mino.rotate();\n//         Mino.lower();\n//     } else {\n//     console.log('blocked?', Mino.isDownBlocked);\n//     Mino.makeStatic(); //freeze block in place\n//     generateTTetrimino();\n//     }\n// }\n\n// function fallingI() {\n//     if (!Mino.isDownBlocked) {\n//         Mino.rotate();\n//         Mino.lower();\n//     } else {\n//     console.log('blocked?', Mino.isDownBlocked);\n//     Mino.makeStatic(); //freeze block in place\n//     generateITetrimino();\n//     }\n// }\n\n// function fallingS() {\n//     if (!Mino.isDownBlocked) {\n//         Mino.rotate();\n//         Mino.lower();\n//     } else {\n//     console.log('blocked?', Mino.isDownBlocked);\n//     Mino.makeStatic(); //freeze block in place\n//     generateSTetrimino();\n//     }\n// }\n\n// function fallingL() {\n//     if (!Mino.isDownBlocked) {\n//         Mino.rotate();\n//         Mino.lower();\n//     } else {\n//     console.log('blocked?', Mino.isDownBlocked);\n//     Mino.makeStatic(); //freeze block in place\n//     generateLTetrimino();\n//     }\n// }\n\n\n// function fallingJ() {\n//     if (!Mino.isDownBlocked) {\n//         Mino.rotate();\n//         Mino.lower();\n//     } else {\n//     console.log('blocked?', Mino.isDownBlocked);\n//     Mino.makeStatic(); //freeze block in place\n//     generateJTetrimino();\n//     }\n// }\n\n\n\n\n\n\n// OLD ROTATE CODE\n// function isDownRotateBlocked(currentArray, nextArray) {\n        //     let j;\n        //     const currentRowMin = Math.min(...currentArray.map( e => e.row));\n        //     const nextRowMin = Math.min(...nextArray.map( e => e.row));\n        //     console.log(currentRowMin);\n        //     console.log(nextRowMin);\n        //     for (j=0;j<currentArray.length;j++) {\n        //         if ((currentRowMin > nextRowMin && nextArray[j].className === 'static') || (currentRowMin > nextRowMin && nextArray[j].row < grid.floor)) {\n        //             return true;\n        //             break;\n        //         }\n        //     }\n        //     return false;\n        // }\n\n        // //i need to sort out/find the highest column number for each array.\n        // function isRightRotateBlocked(currentArray, nextArray) {\n        //     let j;\n        //     const currentColumnMax = Math.max(...currentArray.map( e => e.column));\n        //     const nextColumnMax = Math.max(...nextArray.map( e => e.column));\n        //     console.log(currentColumnMax);\n        //     console.log(nextColumnMax);\n        //     for (j=0;j<currentArray.length;j++) {\n        //         if ((currentColumnMax < nextColumnMax && nextArray[j].className === 'static') || (currentColumnMax < nextColumnMax && nextArray[j].column > grid.rightedge)) {\n        //             console.log('right rotate blocked');\n        //             return true;\n        //             break;\n        //         }\n        //     }\n        //     return false;\n        // }\n\n        // function isLeftRotateBlocked(currentArray, nextArray) {\n        //     let j;\n        //     const currentColumnMin = Math.min(...currentArray.map( e => e.column));\n        //     const nextColumnMin = Math.min(...nextArray.map( e => e.column));\n        //     console.log(currentColumnMin);\n        //     console.log(nextColumnMin);\n        //     for (j=0;j<currentArray.length;j++) {\n        //         if ((currentColumnMin > nextColumnMin && nextArray[j].className === 'static') || (currentColumnMin > nextColumnMin && nextArray[j].column < leftedge)) {\n        //             console.log('left rotate blocked');\n        //             return true;\n        //             break;\n        //         }\n        //     }\n        //     return false;\n        // }\n\n        // function isStuck(currentArray, nextArray) {\n        //     for (i=0;i<nextArray.length;i++)\n        //     if (isLeftRotateBlocked(currentArray, nextArray) && ( window[`r${nextArray[i].row}c${nextArray[i].column + 1}`].className === 'static' || window[`r${nextArray[i].row - 1}c${nextArray[i].column + 1}`].className === 'static' )){\n        //         return true;\n        //         break;\n        //     }\n        // }\n\n    //For Some reason Could NOT get this to work\n    //     function isRightRotateBlockedOneSpace(currentArray, nextArray) {\n    //         let j;\n    //         const currentColumnMax = Math.max(...currentArray.map( e => e.column));\n    //         const nextColumnMax = Math.max(...nextArray.map( e => e.column));\n    //         console.log(currentColumnMax);\n    //         console.log(nextColumnMax);\n    //         for (j=0;j<currentArray.length;j++) {\n    //             if ((nextColumnMax > currentColumnMax && nextArray[3].className === 'static' && nextArray[2].className !== 'static') || (nextColumnMax > currentColumnMax && nextArray[2].column === grid.rightedge)) {\n    //                 console.log('right rotate blocked one space');\n    //                 return true;\n    //                 break;\n    //             }\n    //         }\n    //         return false;\n    // }\n\n        // function isITetroRightBlockedTwo(currentArray, nextArray) {\n        //     let j;\n        //     const currentColumnMax = Math.max(...currentArray.map( e => e.column));\n        //     const nextColumnMax = Math.max(...nextArray.map( e => e.column));\n        //     console.log(currentColumnMax);\n        //     console.log(nextColumnMax);\n        //     for (j=0;j<currentArray.length;j++) {\n        //         if (nextArray[2].className === 'static' || nextArray[2].column > grid.rightedge) {\n        //             console.log('right blocked two spaces');\n        //             return true;\n        //             break;\n        //         }\n        //     }\n        //     return false;\n        // }\n\n        // function isITetroRightBlockedOne(currentArray, nextArray) {\n        //     let j;\n        //     const currentColumnMax = Math.max(...currentArray.map( e => e.column));\n        //     const nextColumnMax = Math.max(...nextArray.map( e => e.column));\n        //     console.log(currentColumnMax);\n        //     console.log(nextColumnMax);\n        //     for (j=0;j<currentArray.length;j++) {\n        //         if (nextArray[3].className === 'static' || nextArray[3].column > grid.rightedge) {\n        //             console.log('right blocked one space');\n        //             return true;\n        //             break;\n        //         }\n        //     }\n        //     return false;\n        // }\n\n        // function isITetroLeftBlocked(currentArray, nextArray) {\n        //     let j;\n        //     const currentColumnMin = Math.min(...currentArray.map( e => e.column));\n        //     const nextColumnMin = Math.min(...nextArray.map( e => e.column));\n        //     console.log(currentColumnMin);\n        //     console.log(nextColumnMin);\n        //     for (j=0;j<currentArray.length;j++) {\n        //         if ((nextArray[0].className === 'static') || (currentColumnMin > nextColumnMin && nextArray[0].column < leftedge)) {\n        //             return true;\n        //             break;\n        //         }\n        //     }\n        //     return false;\n        // }\n\n\n\n\n// TESTING CODE, WORKS\n// const newdiv = document.createElement('DIV');\n// const newdiv2 = document.createElement('DIV');\n// newdiv.setAttribute('class', 'blank');\n// newdiv2.setAttribute('class', 'blank');\n// board.appendChild(newdiv);\n// board.appendChild(newdiv2);\n\n// let xpos = 15;\n// let ypos = 30;\n\n// newdiv.xpos = xpos;\n// newdiv.ypos = ypos;\n\n// newdiv2.xpos = 20;\n// newdiv2.ypos = 40;\n\n// newdiv2.style.bottom = '40px';\n\n// console.log(newdiv.xpos, newdiv.ypos);\n// console.log(newdiv2.xpos, newdiv2.ypos);\n// console.log(Object.getOwnPropertyNames(newdiv));\n// newdiv.style.backgroundColor = 'black';\n// console.log(newdiv.style); //QUESTION!!! where is this property hidden? cannot view it in console without directly logging it.\n//\n\n\n\n\n\n\n// Error: this code overwrites the cssproperties prototype\n\n// class Template {\n//     constructor(xpos, ypos) {\n//         this.xpos = xpos;\n//         this.ypos = ypos;\n//     }\n// }\n\n// Object.setPrototypeOf(newdiv, new Template(xpos, ypos))\n//\n\n\n\n\n\n//class extension that i did\n//seems pointless now\n//\n// class Template {\n//     constructor() {\n//         this.color = 'blue';\n//         this.height = 40;\n//         this.width = 40;\n//     }\n// }\n\n// class Square extends Template {\n//     constructor(xpos, ypos) {\n//         super(); //enables use of this, some reason\n//         this.xpos = xpos;\n//         this.ypos = ypos;\n//     }\n// };\n\n// let sq = new Square(0, 5);\n// let te = new Template();\n\n// // console.log(te.color);\n// console.log(sq);\n// console.log(sq.height);\n// console.log(sq.color);\n// sq.color = 'black';\n// console.log(sq.color);\n// console.log(te.color);\n\n\n\n//# sourceURL=webpack://tetris/./src/index.js?");

/***/ }),

/***/ "./src/tetrimino.js":
/*!**************************!*\
  !*** ./src/tetrimino.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => /* binding */ Tetrimino\n/* harmony export */ });\nclass Tetrimino {\n    constructor(grid){\n        this.grid = grid;\n        this.name = 'terminino object';\n        this.lTetrimino = [this.grid.r16c7, this.grid.r16c8, this.grid.r16c9, this.grid.r17c9]; \n        this.jTetrimino = [this.grid.r16c7, this.grid.r16c8, this.grid.r16c9, this.grid.r17c7];\n        this.sqTetrimino = [this.grid.r16c8, this.grid.r16c9, this.grid.r17c8, this.grid.r17c9]; //square shape\n        this.iTetrimino = [this.grid.r16c7, this.grid.r16c8, this.grid.r16c9, this.grid.r16c10];\n        this.tTetrimino = [this.grid.r16c7, this.grid.r16c8, this.grid.r16c9, this.grid.r17c8];\n        this.z1Tetrimino = [this.grid.r16c8, this.grid.r16c9, this.grid.r17c7, this.grid.r17c8];\n        this.sTetrimino = [this.grid.r16c7, this.grid.r16c8, this.grid.r17c8, this.grid.r17c9];\n        this.arrayOfTetriminos = [this.lTetrimino, this.jTetrimino, this.sqTetrimino, this.iTetrimino, this.tTetrimino, this.z1Tetrimino, this.sTetrimino];\n        this.arrayOfShapeOrientations = ['l1', 'j1', 'sq1', 'i1', 't1', 'z1', 's1'];\n        this.shapeOrientation;\n        this.deletedrow = 0;\n    }\n\n     //getArrayOfActiveSquares()\n    get actives() {\n        let array = [];\n        const arrayLikeObject = document.getElementsByClassName('active');\n        let i;\n        for (i=0;i<arrayLikeObject.length;i++) {\n            array.push(arrayLikeObject[i]);\n        }\n        return array;\n    }\n\n     //generateTetriminos()\n    generate() {\n        const num = Math.floor(Math.random() * Math.floor(7)); //generates random number from zero to max, excluding max\n        const tetrimino = this.arrayOfTetriminos[num]; \n        this.shapeOrientation = this.arrayOfShapeOrientations[num];\n        tetrimino.forEach(e => e.className = 'active');\n        \n        // console.log(shapeOrientation);\n    }\n\n    highlightRow() {\n        function isOccupied(elem, index, arr) { //callback function for .every\n            return elem.className !== 'blank';\n        }\n        let k;\n        for (k=0;k<this.grid.maxRows;k++) {\n            if (this.grid.ArrayOfVisibleRows[k].every(isOccupied) && this.isDownBlocked) {\n                console.log('this.isDownBlocked', this.isDownBlocked);\n                this.grid.ArrayOfVisibleRows[k].forEach(e => {\n                    e.style.backgroundColor = '#ff6ec7'\n                })\n            }\n        }\n    }\n    \n\n    lower() {\n\n        const array = this.actives //must set to an array so that it can remember the positions of the active array even after class is set to blank.\n        let i;\n        for(i=0;i<array.length;i++) {\n            array[i].setAttribute('class','blank');\n        }\n\n        for(i=0;i<array.length;i++) {\n            let newRowNum = array[i].row - 1;\n            document.getElementById(`r${newRowNum}c${array[i].column}`).setAttribute('class','active');   //adjustClassesDown()\n        }       \n\n        this.highlightRow();\n\n    }\n\n    moveUp() {\n        const array = this.actives\n        let i;\n        for(i=0;i<array.length;i++) {\n            array[i].setAttribute('class','blank');\n        }\n        for(i=0;i<array.length;i++) {\n            let newRowNum = array[i].row + 1;\n            document.getElementById(`r${newRowNum}c${array[i].column}`).setAttribute('class','active');   //adjustClassesUp()\n        }\n    }\n\n    moveLeft() {\n            const array = this.actives;\n            let i;\n            for(i=0;i<array.length;i++) {\n                array[i].setAttribute('class','blank');\n            }\n            for(i=0;i<array.length;i++) {\n                let newColumnNum = array[i].column - 1;\n                document.getElementById(`r${array[i].row}c${newColumnNum}`).setAttribute('class','active');   //adjustClasses\n            }  \n    }\n\n    moveRight() {\n            const array = this.actives;\n            let i;\n            for(i=0;i<array.length;i++) {\n                array[i].setAttribute('class','blank');\n            }\n            for(i=0;i<array.length;i++) {\n                let newColumnNum = array[i].column + 1;\n                document.getElementById(`r${array[i].row}c${newColumnNum}`).setAttribute('class','active');  //adjustClasses\n            }\n        }\n\n    //pathBlocked()\n    get isDownBlocked() {\n        const path = this.actives.map((e) => document.getElementById(`${e.idbelow}`))\n        // console.log(path);\n        let j;\n        for (j=0;j<this.actives.length;j++) {\n            if (path[j].className === 'static' || path[j].row < this.grid.floor) {\n                return true;\n                break;\n            }\n        }\n        return false;\n    }\n\n\n    get isRightBlocked() {\n        const path = this.actives.map((e) => document.getElementById(`${e.idright}`))\n        let j;\n        for (j=0;j<this.actives.length;j++) {\n            if (path[j].className === 'static' || path[j].column > this.grid.rightedge) {\n                return true;\n                break;\n            }\n        }\n        return false;\n    }\n\n    //ALSO GET AN ERROR HERE BECAUSE THERE ARE NO COLUMNSS LEFTWARDS THAT HAVE THE ID OF ID LEFT! NEED TO CREATE MORE INVISIBLE COLUMNS - done\n    get isLeftBlocked() {\n        const path = this.actives.map((e) => document.getElementById(`${e.idleft}`))\n        // console.log(path);\n        let j;\n        for (j=0;j<this.actives.length;j++) {\n            if (path[j].className === 'static' || path[j].column < this.grid.leftedge) {\n                return true;\n                break;\n            }\n        }\n        return false;\n    }\n\n\n  \n    makeStatic() {\n        this.actives.forEach( element => element.setAttribute('class', 'static'))\n    }\n\n    \n    slam() {\n        let i;\n        for (i=0; i<15; i++) {\n            if (!this.isDownBlocked) {\n                this.lower();\n            } else {\n                break;\n            }\n        }\n    }\n\n    getStatics() {\n        let statics = document.getElementsByClassName('static');\n        let array = [];\n        let i;\n        for (i=0;i<statics.length;i++) {\n            array.push(statics[i])\n        }\n        return array;\n    }\n    \n    \n    staticReassign(aboveSquare) { //takes an element. as long as elements go from bottom up should nto overwrite itself.\n        aboveSquare.className = 'blank';\n        this.grid[aboveSquare.idbelow].className = 'static';\n    }\n    \n    \n    //Finds all statics above the deleted row, then move them down\n    downShiftStatics() {\n        console.log('deleted row: ', this.deletedrow);\n        this.getStatics().forEach( e => {\n            if (e.row > this.deletedrow) {\n                this.staticReassign(e);\n            }\n        })\n    }\n\n    clearRow(index) {\n        this.removeHighlight();\n        this.deletedrow = this.grid.ArrayOfVisibleRows[index][0].row;\n        this.grid.ArrayOfVisibleRows[index].forEach( e => {\n            e.className = 'blank';\n        })\n    }\n    \n    \n    \n    checkRowState() {\n        let rowsCleared = 0;\n    \n        function isFilled(elem, index, arr) { //callback function for .every\n            return elem.className === 'static';\n        }\n    \n        let i;\n        for (i=0;i<this.grid.maxRows;i++) {\n            if (this.grid.ArrayOfVisibleRows[i].every(isFilled)) {\n                this.clearRow(i);\n                this.downShiftStatics();\n                speedTracker += 1;\n                rowsCleared += 1; //for calculating score bonuses\n                i -= 1; //accounts for multiple rows clearing 'at once.'\n               \n            }\n        }\n    \n        if (rowsCleared === 1) {\n            points += 1;\n            updateScore();\n            updateSpeed();\n            bonusScreen.innerHTML = '<div>+1</div>';\n            bonusScreen.style.display = 'flex';\n            setTimeout( ()=> {\n                bonusScreen.style.display = 'none';\n            }, 1300)\n        }\n        if (rowsCleared === 2) {\n            points += 4 ;//includes bonus\n            updateScore();\n            updateSpeed();\n            bonusScreen.innerHTML = '<div>+4!</div>';\n            bonusScreen.style.display = 'flex';\n            setTimeout( ()=> {\n                bonusScreen.style.display = 'none';\n            }, 1300)\n        }\n        if (rowsCleared === 3) {\n            points += 8 ;//includes bonus\n            updateScore();\n            bonusScreen.innerHTML = '<div>+8!</div>';\n            bonusScreen.style.display = 'flex';\n            setTimeout( ()=> {\n                bonusScreen.style.display = 'none';\n            }, 1300)\n        }\n        if (rowsCleared === 4) {\n            points += 14 ;//includes bonus\n            updateScore();\n            updateSpeed();\n            bonusScreen.innerHTML = '<div>TETRIS!</div><div>+14!</div>';\n            bonusScreen.style.display = 'flex';\n            setTimeout( ()=> {\n                bonusScreen.style.display = 'none';\n            }, 1300)\n        }\n    }\n    \n    removeHighlight() {\n        let j;\n        let array = [];\n        this.grid.divArray.forEach( e => {\n            if (e.style.backgroundColor = 'lime') {\n                array.push(e)\n            }\n        })\n        for (j=0;j<array.length;j++) {\n            array[j].style.backgroundColor = '';\n        }\n    }\n\n\n    //isTopBound\n\n\n\n        //NOTES: RIGHT NOW GAME CURRENTLY DOESNT KNWO IF SOMETHING IS RIGHT ROTATE BOUND SPEIFICIALLY. ONLY KNOWS THAT IT CANNOT ROTATE IN GENERAL, SOMEWHERE.\n        //IS IT POSSIBLE TO (WITH AN EXCEPTION FOR I TETRO) TO SIMPLY, WHEN ROTATE IS CALLED, IF SHAPE IS RIGHT BLOCKED, SHIFT IT RIGHT BEFORE ROTATING. (YES).\n        //CORRECTION NO! RIGHT BLOCKED IS NOT HTE SAME AS ROTATE BLOCKED. RIGHT BLOCKED MEANS THERE IS NO SPACE TO THE RIGHT. RIGHT ROTATE BLOCKED MEANS...\n        //EVEN IF THERE IS NO SPACE RIGHT, IF THE ROTATION DOESNT OCCUPY TEH SPACE TO THE RIGHT, ROTATION IS FINE!\n        //SHOULD A DOWNWARDLY ROTATEBLOCKED SHAPE BE ALLOWED TO UPSHIFT AND ROTATE? (MAYBE)\n\n    //Rotate\n    rotate() {\n        const _this = this;  // for referencing the Termino object inside of the inner functions.\n\n        //I BELIEVE A STUCK FUNCTION WILL STOP MANY OF THESE WEIRD ERASURES.\n        //THE ERASURES COME FROM THE HYPOTHETICAL POSITION BEING OKAY DESPITE IN A REAL WORLD SENSE IT SEEMS WRONG BECAUSE THE TETRO\n        //COULD NOT ACTUALLY PASS THROUGH THE STATIC GRID, BUT ITS NOT ACTUALLY LITERALLY ROTATING\n        //THEN THE PIECE SLIDES LEFT OR RIGHT, ERASING THE STATIC GRID, AND THEN IS REASSIGNED TO THE NEW HYPOTHETICLA POSITION\n        //BUT THE GRID WAS DAMAGED DURING HTE SLIDE BEFORE THE ROTATION.\n        //YOU COULD ROTATE FIRST THEN SLIDE BUT THAT WOULD ALSO ERASE.\n        //WE NEED A STUCK FUNCTION THAT PREEMPTS THESE STRANGE MOVES.\n        //what defines STUCK? \n        //STUCK = IF THERE IS A PIECE INBETWEN WHERE IT STARTS AND WHERE IT ROTATES TO.\n        //DO I NEED A TRACKER FOR THIS?\n\n\n        //if the natural rotation is blocked, the handleRotate() tests a hypothetical left(or right) shift and rotate. \n        //this function is part of the hypothetical left and rotate, acting as a failsafe that the shift left doesnt move through another static piece.\n        //also this function should serve to block strange visual shifts that may be logically sound, but appear awkward.\n        function isStuck(activeArray, iddirection) { \n            let testArray = [];\n            activeArray.forEach(e => {\n                testArray.push(_this.grid[e[iddirection]]);\n            })\n            console.log(testArray);\n            \n            let sideContactPoints = 0; //logic might be a little iffy on this one\n            activeArray.forEach( e => {\n                if ((_this.grid[e.idleft].className === 'static' || _this.grid[e.idright].className === 'static')) {\n                    sideContactPoints += 1\n                }\n            })\n            console.log('side contact points:', sideContactPoints)\n            \n            let multifaceContactPoints = 0;\n            let staticArray = _this.getStatics();\n            console.log(staticArray);\n            staticArray.forEach( e => {\n                if (\n                   (_this.grid[e.idleft].className === 'active' && _this.grid[e.idbelow].className === 'active') \n                || (_this.grid[e.idleft].className === 'active' && _this.grid[e.idabove].className === 'active') \n                || (_this.grid[e.idright].className === 'active' && _this.grid[e.idleft].className === 'active') \n                || (_this.grid[e.idright].className === 'active' && _this.grid[e.idbelow].className === 'active') \n                || (_this.grid[e.idright].className === 'active' && _this.grid[e.idabove].className === 'active') \n                ){\n                    multifaceContactPoints += 1;\n                }\n\n            })\n\n            let i;\n            for (i=0;i<testArray.length;i++) {\n                if (testArray[i].className === 'static') {\n                    return true;\n                }\n            }\n\n            if (sideContactPoints >= 1 && iddirection === 'idabove') {\n                return true;\n            }\n\n            if (multifaceContactPoints >= 1) {\n                return true;\n            }\n\n            return false;\n        }\n\n\n        function isRotateBlocked(array) { //takes an array of elements which represent the hypothetical rotated position\n           let j;\n           for (j=0;j<array.length;j++) {\n               if (array[j].className === 'static' || array[j].column < _this.grid.leftedge || array[j].column > _this.grid.rightedge || array[j].row < _this.grid.floor) {\n                   return true;\n               }\n           }\n            return false;\n        }\n\n\n        function handleRotationV2(activeArray, nextArray, nextShape) {\n            if (isRotateBlocked(nextArray()) === true) {\n                //test hypotheticals;\n                //rotate if possible (aka move then reassign, to a position we know will have no blockage)\n                if (testLeftHypothetical(activeArray(), nextArray())) {\n                    _this.moveLeft();\n                    console.log('moved left')\n                    reassign(activeArray(), nextArray());\n                    console.log('reassigned')\n                    _this.shapeOrientation = nextShape;\n                \n                } else if (testRightHypothetical(activeArray(), nextArray())) {\n                    _this.moveRight();\n                    reassign(activeArray(), nextArray());\n                    _this.shapeOrientation = nextShape;\n                    console.log('moved right')\n                } else if (testUpHypothetical(activeArray(), nextArray())) {\n                    _this.moveUp();\n                    reassign(activeArray(), nextArray());\n                    _this.shapeOrientation = nextShape;\n                    console.log('moved up')\n                } else {\n                    console.log('blocked: cannot rotate');\n                    return;\n                }\n            } else if (!isRotateBlocked(nextArray())) {\n                reassign(activeArray(), nextArray());\n                _this.shapeOrientation = nextShape;\n            }\n        }\n\n        function handleITetroRotation(activeArray, nextArray, nextShape) {\n            if (isRotateBlocked(nextArray()) === true) {\n                //test hypotheticals;\n                //rotate if possible (aka move then reassign, to a position we know will have no blockage)\n                if (testLeftHypothetical(activeArray(), nextArray())) {\n                    _this.moveLeft();\n                    reassign(activeArray(), nextArray());\n                    _this.shapeOrientation = nextShape;\n                } else if (testDoubleLeftHypothetical(activeArray(), nextArray())) {\n                    _this.moveLeft();\n                    _this.moveLeft();\n                    reassign(activeArray(), nextArray());\n                    _this.shapeOrientation = nextShape;\n                } else if (testRightHypothetical(activeArray(), nextArray())) {\n                    _this.moveRight();\n                    reassign(activeArray(), nextArray());\n                    _this.shapeOrientation = nextShape;\n                } else if (testUpHypothetical(activeArray(), nextArray())) {\n                    _this.moveUp();\n                    reassign(activeArray(), nextArray());\n                    _this.shapeOrientation = nextShape;\n                } else {\n                    console.log('SHAPE I TETRO IS BLOCKED');\n                    return;\n                }\n            } else if (!isRotateBlocked(nextArray())) {\n                reassign(activeArray(), nextArray());\n                _this.shapeOrientation = nextShape;\n            }\n        }\n\n        function testLeftHypothetical(activeArray, nextArray) {\n            let testArray = [];\n            nextArray.forEach(e => {\n                testArray.push(_this.grid[e.idleft]);\n            })\n            console.log(testArray);\n            if (isRotateBlocked(testArray)) {\n                return false;\n            } else if (isStuck(activeArray, 'idleft')) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n\n        function testDoubleLeftHypothetical(activeArray, nextArray) {\n            let testArray = [];\n            nextArray.forEach(e => {\n                testArray.push(_this.grid[_this.grid[e.idleft].idleft]);\n            })\n            console.log(testArray);\n            if (isRotateBlocked(testArray)) {\n                return false;\n            } else if (isStuck(activeArray, 'idleft')) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n\n        function testRightHypothetical(activeArray, nextArray) {\n            let testArray = []\n            nextArray.forEach(e => {\n                testArray.push(_this.grid[e.idright]);\n            })\n            console.log(testArray);\n            if (isRotateBlocked(testArray)) {\n                return false;\n            } else if (isStuck(activeArray, 'idright')) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n\n        function testUpHypothetical(activeArray, nextArray) {\n            let testArray = []\n            nextArray.forEach(e => {\n                testArray.push(_this.grid[e.idabove]);\n            })\n            console.log(testArray);\n            if (isRotateBlocked(testArray)) {\n                return false;\n            } else if (isStuck(activeArray, 'idabove')) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n\n\n        function reassign(currentArr, newArr) {\n            currentArr.forEach( e => {\n                e.className = 'blank'; \n            })\n            newArr.forEach(e => {\n                e.className = 'active';\n            })\n        }\n\n        function getActives() {\n            let array = [];\n            const arrayLikeObject = document.getElementsByClassName('active');\n            let i;\n            for (i=0;i<arrayLikeObject.length;i++) {\n                array.push(arrayLikeObject[i]);\n            }\n            return array;\n        }\n\n\n        //PREVIOUS ROTATION HANDLER FUNCTION\n        // function handleRotation(activeArray, nextArray, nextShape) {\n\n        //    if (isLeftRotateBlocked(activeArray(), nextArray())) {\n        //         _this.moveRight();\n        //         reassign(activeArray(), nextArray());\n        //         _this.shapeOrientation = nextShape; \n        //     } else if (isRightRotateBlocked(activeArray(), nextArray())) {\n        //         _this.moveLeft();\n        //         reassign(activeArray(), nextArray());\n        //         _this.shapeOrientation = nextShape; \n        //     } else if (isDownRotateBlocked(activeArray(), nextArray())) {\n        //         _this.moveUp();\n        //         reassign(activeArray(), nextArray());\n        //         _this.shapeOrientation = nextShape; \n        //     } else {\n        //         reassign(activeArray(), nextArray());\n        //         _this.shapeOrientation = nextShape; \n        //     } \n        // }\n \n\n        //BIG IF\n\n        if (_this.shapeOrientation === 'z1') {\n            function makeNewArray() {\n                let newPositionArray = []; //these are ids not objects. MAKE THEM OBJECTS BELOW SO THEY CAN EASILY FIT INTO HANDLEROTATION()\n                newPositionArray.push(_this.grid[`r${_this.actives[0].row + 1}c${_this.actives[0].column + 1}`]) \n                newPositionArray.push(_this.grid[`r${_this.actives[1].row + 2}c${_this.actives[1].column}`]) \n                newPositionArray.push(_this.grid[`r${_this.actives[2].row - 1}c${_this.actives[2].column + 1}`]) \n                newPositionArray.push(_this.grid[_this.actives[3].id]);\n                return newPositionArray;\n         }\n    \n         handleRotationV2(getActives, makeNewArray, 'z2');\n       \n    } else if (_this.shapeOrientation === 'z2') {\n        \n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 1}c${_this.actives[1].column - 1}`]) \n            newPositionArray.push(_this.grid[`r${_this.actives[2].row - 1}c${_this.actives[2].column - 1}`]) \n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 2}c${_this.actives[3].column}`]) \n            return newPositionArray;\n        }\n\n        handleRotationV2(getActives, makeNewArray, 'z1');\n    } else if (_this.shapeOrientation === 't1') {\n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row - 1}c${_this.actives[0].column + 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[_this.actives[2].id]);\n            newPositionArray.push(_this.grid[_this.actives[3].id]);\n            return newPositionArray;\n        }\n            \n        handleRotationV2(getActives, makeNewArray, 't2');\n    } else if (_this.shapeOrientation === 't2') {\n        \n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[_this.actives[2].id]);\n            newPositionArray.push(_this.grid[_this.actives[0].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 1}c${_this.actives[3].column - 1}`]); \n            return newPositionArray;\n        }\n        \n        handleRotationV2(getActives, makeNewArray, 't3');\n    } else if (_this.shapeOrientation === 't3') {\n        \n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[_this.actives[0].id]);\n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[_this.actives[2].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row + 1}c${_this.actives[3].column - 1}`]); \n            return newPositionArray;\n        }\n\n\n        handleRotationV2(getActives, makeNewArray, 't4');\n    } else if (_this.shapeOrientation === 't4') {\n        \n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 1}c${_this.actives[3].column + 1}`]); \n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[_this.actives[2].id]);\n            newPositionArray.push(_this.grid[_this.actives[3].id]);\n            return newPositionArray;\n        }\n   \n        handleRotationV2(getActives, makeNewArray, 't1');\n    } else if (_this.shapeOrientation === 'i1') {\n        \n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row - 1}c${_this.actives[0].column + 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[2].row + 1}c${_this.actives[2].column - 1}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row + 2}c${_this.actives[3].column - 2}`]);\n            return newPositionArray;\n        }\n\n        handleITetroRotation(getActives, makeNewArray, 'i2');\n    } else if (_this.shapeOrientation === 'i2') {\n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 1}c${_this.actives[0].column - 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[2].row - 1}c${_this.actives[2].column + 1}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 2}c${_this.actives[3].column + 2}`]);\n            return newPositionArray;\n        }\n       \n        handleITetroRotation(getActives, makeNewArray, 'i1');\n    } else if (_this.shapeOrientation === 's1') {\n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 2}c${_this.actives[0].column}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[1].row + 1}c${_this.actives[1].column - 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[2].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 1}c${_this.actives[3].column - 1}`]);\n            return newPositionArray;\n        }\n        \n        handleRotationV2(getActives, makeNewArray, 's2');\n    } else if (_this.shapeOrientation === 's2') {\n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 1}c${_this.actives[0].column + 1}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[1].row - 1}c${_this.actives[1].column + 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[2].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 2}c${_this.actives[3].column}`]);\n            return newPositionArray;\n        }\n        handleRotationV2(getActives, makeNewArray, 's1');\n    } else if (_this.shapeOrientation === 'l1') {\n       \n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 1}c${_this.actives[0].column + 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[2].row - 1}c${_this.actives[2].column - 1}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 2}c${_this.actives[3].column}`]);\n            return newPositionArray;\n        }\n\n        //I GET AN ERROR CHECKING THIS PROPERTY WHEN THE PIECE IS AT THE WALL BECAUSE THERE ARE NO IDS \n        //TO MATCH COLUMNS THAT DONT EXIST AKA EXTEND PAST THE WALL\n        //NEED TO ADD COLUMNS!\n\n        handleRotationV2(getActives, makeNewArray, 'l2');\n           \n    } else if (_this.shapeOrientation === 'l2') {\n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 1}c${_this.actives[0].column - 1}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[1].row}c${_this.actives[1].column - 2}`]);\n            newPositionArray.push(_this.grid[_this.actives[2].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 1}c${_this.actives[3].column + 1}`]);\n            return newPositionArray;\n        }\n\n        handleRotationV2(getActives, makeNewArray, 'l3');\n        \n    } else if (_this.shapeOrientation === 'l3') {\n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 2}c${_this.actives[0].column}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[1].row + 1}c${_this.actives[1].column + 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[2].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 1}c${_this.actives[3].column - 1}`]);\n            return newPositionArray;\n        }\n\n         handleRotationV2(getActives, makeNewArray, 'l4');\n\n    } else if (_this.shapeOrientation === 'l4') {\n\n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 1}c${_this.actives[0].column - 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[2].row}c${_this.actives[2].column + 2}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 1}c${_this.actives[3].column + 1}`]);\n            return newPositionArray;\n        }\n\n        handleRotationV2(getActives, makeNewArray, 'l1');\n\n    } else if (_this.shapeOrientation === 'j1') {\n        \n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 1}c${_this.actives[0].column + 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[2].row - 1}c${_this.actives[2].column - 1}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row}c${_this.actives[3].column + 2}`]);\n            return newPositionArray;\n        }\n\n        handleRotationV2(getActives, makeNewArray, 'j2');\n    } else if (_this.shapeOrientation === 'j2') {\n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 1}c${_this.actives[0].column - 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[1].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[2].row - 1}c${_this.actives[2].column + 1}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 2}c${_this.actives[3].column}`]);\n            return newPositionArray;\n        }\n        handleRotationV2(getActives, makeNewArray, 'j3');\n    } else if (_this.shapeOrientation === 'j3') {\n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row}c${_this.actives[0].column - 2}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[1].row + 1}c${_this.actives[1].column + 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[2].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 1}c${_this.actives[3].column - 1}`]);\n            return newPositionArray;\n        }\n        handleRotationV2(getActives, makeNewArray, 'j4');\n    } else if (_this.shapeOrientation === 'j4') {\n        function makeNewArray() {\n            let newPositionArray = [];\n            newPositionArray.push(_this.grid[`r${_this.actives[0].row + 2}c${_this.actives[0].column}`]);\n            newPositionArray.push(_this.grid[`r${_this.actives[1].row + 1}c${_this.actives[1].column - 1}`]);\n            newPositionArray.push(_this.grid[_this.actives[2].id]);\n            newPositionArray.push(_this.grid[`r${_this.actives[3].row - 1}c${_this.actives[3].column + 1}`]);\n            return newPositionArray;\n        }\n        handleRotationV2(getActives, makeNewArray, 'j1');\n    } //end else if\n} //end rotate()  \n} //end of class\n\n//# sourceURL=webpack://tetris/./src/tetrimino.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/index.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;